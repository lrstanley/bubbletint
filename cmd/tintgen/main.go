// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"log/slog"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/go-playground/validator/v10"
	"github.com/iancoleman/strcase"
	"github.com/lucasb-eyer/go-colorful"
)

var logger = slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
	Level: slog.LevelDebug,
}))

var (
	TintUrl         = "https://github.com/charmbracelet/vhs/raw/refs/heads/main/themes.json"
	ColorMapSpecial = []string{
		"SelectionBg", "Cursor",
	}
	ColorMap = []string{
		"Fg", "Bg",
		"Black", "BrightBlack",
		"Blue", "BrightBlue",
		"Cyan", "BrightCyan",
		"Green", "BrightGreen",
		"Purple", "BrightPurple",
		"Red", "BrightRed",
		"White", "BrightWhite",
		"Yellow", "BrightYellow",
	}
)

var (
	val = validator.New(validator.WithRequiredStructEnabled())

	funcMap = template.FuncMap{
		"header": func() string { return header },
		"dynamiccolor": func(t Tint, field string) string {
			r := reflect.ValueOf(&t)
			f := reflect.Indirect(r).FieldByName(field)
			return f.String()
		},
		"rgba": func(hex string) string {
			c, err := colorful.Hex(hex)
			if err != nil {
				return "rgba(0, 0, 0, 0.0)"
			}
			return fmt.Sprintf("rgba(%d, %d, %d, 1)", int(c.R*255), int(c.G*255), int(c.B*255))
		},
		"rgba_go": func(hex string) string {
			// colorfuls library handles 4-length hex colors, in addition to 7-length (accounting for "#").
			c, err := colorful.Hex(hex)
			if err != nil {
				return "nil"
			}
			return fmt.Sprintf("&Color{R: %d, G: %d, B: %d, A: %d}", int(c.R*255), int(c.G*255), int(c.B*255), 255)
		},
		"isbright": func(c string) bool {
			return strings.Contains(c, "Bright")
		},
		"quote": func(s string) string {
			return fmt.Sprintf("%q", s)
		},
	}
	tintsTmpl = template.Must(
		template.New("tints.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/tints.gotmpl"),
	)
	tintHTMLTmpl = template.Must(
		template.New("tint_html.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/tint_html.gotmpl"),
	)
	svgTmpl = template.Must(
		template.New("tint_svg.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/tint_svg.gotmpl"),
	)
	registryTmpl = template.Must(
		template.New("default_registry.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/default_registry.gotmpl"),
	)

	header = `// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by tintgen. DO NOT EDIT.`

	tintReplacer = strings.NewReplacer(
		"+", " Plus",
		"(", "",
		")", "",
	)
)

func main() {
	if len(os.Args) != 2 {
		logger.Error("usage", "error", "output_dir is required") //nolint:all
		os.Exit(1)
	}

	rawTints := fetchTints()

	sort.SliceStable(rawTints, func(i, j int) bool {
		return rawTints[i].Name < rawTints[j].Name
	})

	tintNames := []string{}
	tints := []TintTemplate{}
	for _, tint := range rawTints { //nolint:all
		name := tintReplacer.Replace(tint.Name)

		t := TintTemplate{
			StructName:     strcase.ToCamel(name),
			NameNormalized: strcase.ToSnake(name),
			Tint:           tint,
		}

		var exists bool
		for _, name := range tintNames {
			if name == t.NameNormalized || name == t.StructName {
				exists = true
				break
			}
		}

		// If the tint name already exists, skip it.
		if exists {
			continue
		}

		tintNames = append(tintNames, t.NameNormalized, t.StructName)
		tints = append(tints, t)
	}

	// Create public directory.
	publicDir := filepath.Join(os.Args[1], "public")
	err := os.MkdirAll(publicDir, 0o750)
	if err != nil {
		log.Fatalf("failed to create public directory: %v", err)
	}

	// Generate individual SVG files for each tint.
	for _, tint := range tints {
		svgFilename := filepath.Join(publicDir, fmt.Sprintf("%s.svg", tint.StructName))
		generateFile(svgFilename, svgTmpl, map[string]any{
			"TintTemplate": tint,
			"ColorMap":     ColorMap,
		})
	}

	// Generate HTML file that references the SVG files.
	generateFile(filepath.Join(publicDir, "index.html"), tintHTMLTmpl, map[string]any{
		"Tints": tints,
	})

	generateFile(filepath.Join(os.Args[1], "tints.gen.go"), tintsTmpl, tints)
	generateFile(filepath.Join(os.Args[1], "default_registry.gen.go"), registryTmpl, tints)
}

func fetchTints() (tints []Tint) {
	logger.Info("fetching tint data", "url", TintUrl) //nolint:all
	resp, err := http.Get(TintUrl)                    //nolint:gosec,noctx
	if err != nil {
		panic(err)
	}

	b, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}
	_ = resp.Body.Close()

	var rawTints []Tint
	err = json.Unmarshal(b, &rawTints)
	if err != nil {
		panic(err)
	}

	for _, tint := range rawTints {
		err = val.Struct(tint)
		if err != nil {
			logger.Error("invalid tint", "error", err) //nolint:all
			continue
		}

		tints = append(tints, tint)
	}

	return tints
}

func generateFile(path string, tmpl *template.Template, data any) {
	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = tmpl.Execute(f, data)
	if err != nil {
		panic(err)
	}

	logger.Info("generated file", "file", path) //nolint:all
}
