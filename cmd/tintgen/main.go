// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/go-playground/validator/v10"
	"github.com/iancoleman/strcase"
	"github.com/lucasb-eyer/go-colorful"
)

var logger = slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
	Level: slog.LevelDebug,
}))

var (
	TintUrls = []string{
		"https://github.com/atomcorp/themes/raw/master/app/src/custom-colour-schemes.json",
		"https://github.com/atomcorp/themes/raw/master/app/src/backupthemes.json",
	}
	CredUrls = []string{
		"https://github.com/atomcorp/themes/raw/master/app/src/credits.json",
	}
	ColorMapSpecial = []string{
		"SelectionBg", "Cursor",
	}
	ColorMap = []string{
		"Fg", "Bg",
		"Black", "BrightBlack",
		"Blue", "BrightBlue",
		"Cyan", "BrightCyan",
		"Green", "BrightGreen",
		"Purple", "BrightPurple",
		"Red", "BrightRed",
		"White", "BrightWhite",
		"Yellow", "BrightYellow",
	}
)

var (
	val = validator.New(validator.WithRequiredStructEnabled())

	funcMap = template.FuncMap{
		"header": func() string { return header },
		"urlenc": url.QueryEscape,
		"dynamiccolor": func(t Tint, field string) string {
			r := reflect.ValueOf(&t)
			f := reflect.Indirect(r).FieldByName(field)
			return f.String()
		},
		"rgba": func(hex string) string {
			c, err := colorful.Hex(hex)
			if err != nil {
				return "rgba(0, 0, 0, 0.0)"
			}
			return fmt.Sprintf("rgba(%d, %d, %d, 1)", int(c.R*255), int(c.G*255), int(c.B*255))
		},
		"rgba_go": func(hex string) string {
			// colorfuls library handles 4-length hex colors, in addition to 7-length (accounting for "#").
			c, err := colorful.Hex(hex)
			if err != nil {
				return "nil"
			}
			return fmt.Sprintf("&Color{r: %d, g: %d, b: %d, a: %d}", int(c.R*255), int(c.G*255), int(c.B*255), 255)
		},
		"isbright": func(c string) bool {
			return strings.Contains(c, "Bright")
		},
		"shortbright": func(c string) string {
			return strings.Replace(c, "Bright", "Bright\n", 1)
		},
		"quote": func(s string) string {
			return fmt.Sprintf("%q", s)
		},
	}
	tintsTmpl = template.Must(
		template.New("tints.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/tints.gotmpl"),
	)
	tintSVGTmpl = template.Must(
		template.New("tint_svg.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/tint_svg.gotmpl"),
	)
	tintReadmeTmpl = template.Must(
		template.New("tint_readme.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/tint_readme.gotmpl"),
	)
	registryTmpl = template.Must(
		template.New("default_registry.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/default_registry.gotmpl"),
	)

	header = `// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by tintgen. DO NOT EDIT.`

	tintReplacer = strings.NewReplacer(
		"+", " Plus",
		"(", "",
		")", "",
	)
)

func main() {
	if len(os.Args) != 2 {
		logger.Error("usage", "error", "output_dir is required") //nolint:all
		os.Exit(1)
	}

	rawTints := fetchTints()
	sourceMap := fetchCredits()

	sort.SliceStable(rawTints, func(i, j int) bool {
		return rawTints[i].Name < rawTints[j].Name
	})

	tintNames := []string{}
	tints := []TintTemplate{}
	for _, tint := range rawTints { //nolint:all
		name := tintReplacer.Replace(tint.Name)

		t := TintTemplate{
			StructName:     strcase.ToCamel(name),
			NameNormalized: strcase.ToSnake(name),
			Tint:           tint,
		}

		var exists bool
		for _, name := range tintNames {
			if name == t.NameNormalized || name == t.StructName {
				exists = true
				break
			}
		}

		// If the tint name already exists, skip it.
		if exists {
			continue
		}

		tintNames = append(tintNames, t.NameNormalized, t.StructName)

		if _, ok := sourceMap[tint.Name]; ok {
			t.CreditSources = sourceMap[tint.Name]
		}

		tints = append(tints, t)
	}

	for _, tint := range tints { //nolint:all
		generateFile(filepath.Join(os.Args[1], fmt.Sprintf("svgs/%s.svg", tint.NameNormalized)), tintSVGTmpl, map[string]any{
			"TintTemplate":    tint,
			"ColorMap":        ColorMap,
			"ColorMapSpecial": ColorMapSpecial,
		})
	}

	generateFile(filepath.Join(os.Args[1], "DEFAULT_TINTS.md"), tintReadmeTmpl, tints)
	generateFile(filepath.Join(os.Args[1], "tints.gen.go"), tintsTmpl, tints)
	generateFile(filepath.Join(os.Args[1], "default_registry.gen.go"), registryTmpl, tints)
}

var reStripTrailingComma = regexp.MustCompile(`,\s*\]\s*$`)

func fetchTints() (tints []Tint) {
	for _, url := range TintUrls {
		logger.Info("fetching tint data", "url", url) //nolint:all
		resp, err := http.Get(url)                    //nolint:gosec,noctx
		if err != nil {
			panic(err)
		}

		b, err := io.ReadAll(resp.Body)
		if err != nil {
			panic(err)
		}
		_ = resp.Body.Close()

		b = reStripTrailingComma.ReplaceAll(b, []byte("]"))

		var rawTints []Tint
		err = json.Unmarshal(b, &rawTints)
		if err != nil {
			panic(err)
		}

		for _, tint := range rawTints {
			err = val.Struct(tint)
			if err != nil {
				logger.Error("invalid tint", "error", err) //nolint:all
				continue
			}

			tints = append(tints, tint)
		}
	}

	return tints
}

func fetchCredits() map[string][]CreditSource {
	sourceMap := map[string][]CreditSource{}

	for _, url := range CredUrls {
		resp, err := http.Get(url) //nolint:gosec,noctx
		if err != nil {
			panic(err)
		}

		var rawCredits []Credit
		err = json.NewDecoder(resp.Body).Decode(&rawCredits)
		if err != nil {
			panic(err)
		}
		_ = resp.Body.Close()

		for _, credit := range rawCredits {
			for _, tint := range credit.Tints {
				if _, ok := sourceMap[tint]; !ok {
					sourceMap[tint] = []CreditSource{}
				}

				for _, source := range credit.Sources {
					// Check to see if the credit was already added.
					exists := false
					for _, origSource := range sourceMap[tint] {
						if origSource.Link == source.Link {
							exists = true
							break
						}
					}
					if !exists {
						sourceMap[tint] = append(sourceMap[tint], source)
					}
				}
			}
		}
	}

	return sourceMap
}

func generateFile(path string, tmpl *template.Template, data any) {
	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = tmpl.Execute(f, data)
	if err != nil {
		panic(err)
	}

	logger.Info("generated file", "file", path) //nolint:all
}
